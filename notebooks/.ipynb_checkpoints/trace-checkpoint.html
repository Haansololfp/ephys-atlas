
<!DOCTYPE html>
<html>
<head></head>
<body>
<script type="module">
import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7.7.0/+esm";
import {schemeTableau10} from "https://cdn.skypack.dev/d3-scale-chromatic@3";
import {axisLeft} from "https://cdn.skypack.dev/d3-axis@3";
import {scaleLinear} from "https://cdn.skypack.dev/d3-scale@4";
import {zoom, zoomIdentity} from "https://cdn.skypack.dev/d3-zoom@3";
import {brushX} from "https://cdn.skypack.dev/d3-brush@3";

let alloc_data = {"actions": [0], "elements_size": [1640, 8519680, 6881280, 414304, 320, 193600, 414304, 193600, 860160, 19680, 24576, 80, 80, 80, 80, 80, 320, 64, 5632, 32, 484, 5632, 484, 88, 8000, 88, 80, 88, 800, 320, 64, 32, 2182840, 4365680, 15442240, 2182840, 33770880], "elements_info": [1, 3, 27, 28, 31, 33, 39, 40, 43, 45, 47, 48, 49, 50, 51, 53, 54, 55, 56, 57, 58, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 75, 78, 87, 91, 98], "elements_category": null, "suffix_table": [[0, null], [1, 0], [2, null], [3, 2], [4, null], [5, 4], [6, 5], [7, 6], [8, 7], [9, 8], [10, 9], [11, 10], [12, 11], [13, 12], [14, 13], [15, 14], [16, 15], [17, 16], [18, 17], [19, 18], [20, 19], [21, 20], [22, 21], [23, 22], [24, 23], [25, 24], [26, 25], [27, 26], [28, 2], [29, 24], [30, 29], [31, 30], [32, 24], [33, 32], [34, 24], [35, 34], [36, 35], [37, 36], [38, 37], [39, 38], [40, 30], [41, 24], [42, 41], [43, 42], [44, 29], [45, 44], [46, 41], [47, 46], [48, 2], [49, 2], [50, 2], [51, 2], [52, 24], [53, 52], [54, 2], [55, 2], [56, 2], [57, 2], [58, 2], [36, 36], [37, 59], [38, 60], [59, 61], [60, 38], [61, 2], [62, 2], [63, 2], [64, 2], [65, 2], [66, 2], [67, 61], [68, 61], [69, 61], [70, 29], [71, 73], [72, 74], [73, 29], [74, 76], [75, 77], [76, 29], [77, 79], [78, 80], [77, 81], [79, 82], [77, 83], [80, 84], [81, 85], [82, 86], [83, 80], [77, 88], [84, 89], [85, 90], [86, 80], [77, 92], [79, 93], [77, 94], [80, 95], [81, 96], [87, 97]], "string_table": ["alloc not recorded, stack trace for free:", "b2aad855fe800_0 1.6KiB allocation (1640 bytes)", "<block was allocated before _record_history was enabled>", "b2aad62000000_0 8.1MiB allocation (8519680 bytes)", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/runpy.py:196:_run_module_as_main", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/runpy.py:86:_run_code", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/ipykernel_launcher.py:17:<module>", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/traitlets/config/application.py:1043:launch_instance", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/ipykernel/kernelapp.py:725:start", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/tornado/platform/asyncio.py:195:start", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/asyncio/base_events.py:603:run_forever", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/asyncio/base_events.py:1909:_run_once", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/asyncio/events.py:80:_run", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/ipykernel/kernelbase.py:513:dispatch_queue", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/ipykernel/kernelbase.py:502:process_one", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/ipykernel/kernelbase.py:409:dispatch_shell", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/ipykernel/kernelbase.py:729:execute_request", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/ipykernel/ipkernel.py:422:do_execute", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/ipykernel/zmqshell.py:540:run_cell", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/IPython/core/interactiveshell.py:3009:run_cell", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/IPython/core/interactiveshell.py:3064:_run_cell", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/IPython/core/async_helpers.py:129:_pseudo_sync_runner", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/IPython/core/interactiveshell.py:3269:run_cell_async", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/IPython/core/interactiveshell.py:3448:run_ast_nodes", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/IPython/core/interactiveshell.py:3508:run_code", "/tmp/ipykernel_186693/726351746.py:15:<module>", "/moto/stats/users/hy2562/spike-psvae/spike_psvae/denoise.py:151:make_ci_graph_all_maxCH", "b2aad62b68000_0 6.6MiB allocation (6881280 bytes)", "b2aad85537400_0 404.6KiB allocation (414304 bytes)", "/tmp/ipykernel_186693/726351746.py:49:<module>", "/moto/stats/users/hy2562/spike-psvae/spike_psvae/denoise.py:483:multichan_phase_shift_denoise_preshift_maxCH_neighbor_unshift", "b2aad855cbc00_0 320.0B allocation (320 bytes)", "/tmp/ipykernel_186693/726351746.py:47:<module>", "b2aad855cbe00_0 189.1KiB allocation (193600 bytes)", "/tmp/ipykernel_186693/726351746.py:16:<module>", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/torch/nn/modules/module.py:1145:to", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/torch/nn/modules/module.py:797:_apply", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/torch/nn/modules/module.py:820:_apply", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/torch/nn/modules/module.py:1143:convert", "b2aad85c00000_0 404.6KiB allocation (414304 bytes)", "b2aad85c95c00_0 189.1KiB allocation (193600 bytes)", "/tmp/ipykernel_186693/726351746.py:14:<module>", "/moto/stats/users/hy2562/spike-psvae/spike_psvae/denoise.py:126:make_ci_graph", "b2aad85cd2000_0 840.0KiB allocation (860160 bytes)", "/moto/stats/users/hy2562/spike-psvae/spike_psvae/denoise.py:378:multichan_phase_shift_denoise_preshift_maxCH_neighbor_unshift", "b2aad85dd4800_0 19.2KiB allocation (19680 bytes)", "/moto/stats/users/hy2562/spike-psvae/spike_psvae/denoise.py:127:make_ci_graph", "b2aad85defa00_0 24.0KiB allocation (24576 bytes)", "b2aad85df8600_0 80.0B allocation (80 bytes)", "b2aad85df8800_0 80.0B allocation (80 bytes)", "b2aad85df8a00_0 80.0B allocation (80 bytes)", "b2aad85df8c00_0 80.0B allocation (80 bytes)", "/tmp/ipykernel_186693/726351746.py:42:<module>", "b2aad85df8e00_0 80.0B allocation (80 bytes)", "b2aad85df9000_0 320.0B allocation (320 bytes)", "b2aad85df9200_0 64.0B allocation (64 bytes)", "b2aad85df9400_0 5.5KiB allocation (5632 bytes)", "b2aad85dfaa00_0 32.0B allocation (32 bytes)", "b2aad85dfac00_0 484.0B allocation (484 bytes)", "b2aad85dfae00_0 5.5KiB allocation (5632 bytes)", "b2aad85dfc400_0 484.0B allocation (484 bytes)", "b2aad85dfce00_0 88.0B allocation (88 bytes)", "b2aad85dfd000_0 7.8KiB allocation (8000 bytes)", "b2aad85dff000_0 88.0B allocation (88 bytes)", "b2aad85dff200_0 80.0B allocation (80 bytes)", "b2aad85dff400_0 88.0B allocation (88 bytes)", "b2aad85dff600_0 800.0B allocation (800 bytes)", "b2aad85dffa00_0 320.0B allocation (320 bytes)", "b2aad85dffc00_0 64.0B allocation (64 bytes)", "b2aad85dffe00_0 32.0B allocation (32 bytes)", "/moto/stats/users/hy2562/spike-psvae/spike_psvae/denoise.py:389:multichan_phase_shift_denoise_preshift_maxCH_neighbor_unshift", "/moto/stats/users/hy2562/spike-psvae/spike_psvae/denoise.py:605:roll_by_gather", "b2aafe6cf8e00_0 2.1MiB allocation (2182840 bytes)", "/moto/stats/users/hy2562/spike-psvae/spike_psvae/denoise.py:393:multichan_phase_shift_denoise_preshift_maxCH_neighbor_unshift", "/moto/stats/users/hy2562/spike-psvae/spike_psvae/denoise.py:604:roll_by_gather", "b2aafe7400000_0 4.2MiB allocation (4365680 bytes)", "/moto/stats/users/hy2562/spike-psvae/spike_psvae/denoise.py:392:multichan_phase_shift_denoise_preshift_maxCH_neighbor_unshift", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/torch/nn/modules/module.py:1501:_call_impl", "/moto/stats/users/hy2562/spike-psvae/spike_psvae/denoise.py:46:forward", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/torch/nn/modules/container.py:217:forward", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/torch/nn/modules/activation.py:103:forward", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/torch/nn/functional.py:1457:relu", "b2aafe82ba200_0 14.7MiB allocation (15442240 bytes)", "/moto/stats/users/hy2562/spike-psvae/spike_psvae/denoise.py:49:forward", "/moto/stats/users/hy2562/mambaforge/envs/a/lib/python3.10/site-packages/torch/nn/modules/linear.py:114:forward", "b2aafe9174400_0 2.1MiB allocation (2182840 bytes)", "/moto/stats/users/hy2562/spike-psvae/spike_psvae/denoise.py:45:forward", "b2aafe9434e00_0 32.2MiB allocation (33770880 bytes)"], "initially_allocated": [36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0], "categories": null}

function process_alloc_data(max_entries) {
    let current = []
    let current_data = []
    let data = []
    let max_size = 0

    let total_mem = 0
    let total_summarized_mem = 0
    let timestep = 0

    let max_at_time = []


    let summarized_mem = {elem: 'summarized', timesteps: [], offsets: [total_mem], size: [], color: 0}
    let summarized_elems = {}

    function advance(n) {
        summarized_mem.timesteps.push(timestep)
        summarized_mem.offsets.push(total_mem)
        summarized_mem.size.push(total_summarized_mem)
        timestep += n
        for (let i = 0; i < n; i++) {
            max_at_time.push(total_mem + total_summarized_mem)
        }
    }

    let sizes = alloc_data.elements_size.map((x, i) => [x, i]).sort(([x, xi], [y, yi]) => y - x)

    let draw_elem = {}
    for (const [s, e] of sizes.slice(0, max_entries)) {
        draw_elem[e] = true
    }

    function add_allocation(elem) {
        let size = alloc_data.elements_size[elem]
        current.push(elem)
        let color = elem
        if (alloc_data.elements_category !== null) {
            color = alloc_data.elements_category[elem]
        }
        let e = {elem: elem, timesteps: [timestep], offsets: [total_mem], size: size, color: color}
        current_data.push(e)
        data.push(e)
        total_mem += size
    }

    for (const elem of alloc_data.initially_allocated) {
        if (elem in draw_elem) {
            add_allocation(elem)
        } else {
            total_summarized_mem += alloc_data.elements_size[elem]
            summarized_elems[elem] = true
        }
    }

    for (const action of alloc_data.actions) {
        const elem = action
        const size = alloc_data.elements_size[elem]
        if ( !(elem in draw_elem)) {
            if (elem in summarized_elems) {
                advance(1)
                total_summarized_mem -= size
                summarized_elems[elem] = null
            } else {
                total_summarized_mem += size
                summarized_elems[elem] = true
                advance(1)
            }
            continue
        }
        const idx = current.findLastIndex(x => x === elem)
        // first time we see an action we add it
        // second time we remove it
        if (idx == -1) {
            add_allocation(elem)
            advance(1)
        } else {
            advance(1)
            const removed = current_data[idx]
            removed.timesteps.push(timestep)
            removed.offsets.push(removed.offsets.at(-1))
            current.splice(idx, 1)
            current_data.splice(idx, 1)

            if (idx < current.length) {
                for (let j = idx; j < current.length; j++) {
                    const e = current_data[j]
                    e.timesteps.push(timestep)
                    e.offsets.push(e.offsets.at(-1))
                    e.timesteps.push(timestep + 3)
                    e.offsets.push(e.offsets.at(-1) - size)
                }
                advance(3)
            }
            total_mem -= size
        }
        max_size = Math.max(total_mem + total_summarized_mem, max_size)
    }

    for (const elem of current_data) {
        elem.timesteps.push(timestep)
        elem.offsets.push(elem.offsets.at(-1))
    }
    data.push(summarized_mem)

    return {
        max_size: max_size,
        allocations_over_time: data,
        max_at_time: max_at_time,
        summarized_mem: summarized_mem,
        context_for_id:  (elem) => {
            let strings = []
            let id = alloc_data.elements_info[elem]
            while (id !== null) {
                const [sid, next_id] = alloc_data.suffix_table[id]
                strings.push(alloc_data.string_table[sid])
                id = next_id
            }
            return `${strings.join('\n')}\n`
        }
    }
}

function MemoryPlot(svg, data, left_pad, colors=schemeTableau10) {
    function format_points(d) {
        const size = d.size
        const xs = d.timesteps.map(t => xscale(t))
        const bottom = d.offsets.map(t => yscale(t))
        const m = Array.isArray(size) ? ((t, i) => yscale(t + size[i]))
                                      :  (t => yscale(t + size))
        const top = d.offsets.map(m)
        const p0 = xs.map((x, i) => `${x},${bottom[i]}`)
        const p1 = xs.map((x, i) => `${x},${top[i]}`).reverse()

        return `${p0.join(' ')} ${p1.join(' ')}`
    }

    let max_timestep = data.max_at_time.length
    let max_size = data.max_size

    let width = svg.attr('width')
    let height = svg.attr('height')
    let plot_width = width - left_pad
    let plot_height = height

    let yscale = scaleLinear().domain([0, max_size]).range([plot_height, 0]);
    let heightscale = scaleLinear().domain([0, max_size]).range([0, plot_height]);
    let yaxis = axisLeft(yscale).tickFormat(d3.format("~s"))
    let xscale = scaleLinear().domain([0, max_timestep]).range([0, plot_width])
    let plot_coordinate_space = svg.append("g").attr("transform", `translate(${left_pad}, ${0})`)
    let plot_outer = plot_coordinate_space.append('g')

    function view_rect(a) {
        return a.append('rect').attr('x', 0).attr('y', 0)
                .attr('width', plot_width).attr('height', plot_height)
                .attr('fill', 'white')
    }

    view_rect(plot_outer)

    let cp = svg.append("clipPath").attr("id", "clip")
    view_rect(cp)
    plot_outer.attr('clip-path', "url(#clip)")


    let zoom_group = plot_outer.append("g")
    let scrub_group = zoom_group.append('g')

    let plot = scrub_group.selectAll("polygon")
    .data(data.allocations_over_time)
    .enter()
    .append("polygon")
    .attr('points', format_points)
    .attr('fill', d => colors[d.color % colors.length])

    let axis = plot_coordinate_space.append('g').call(yaxis)


    let scale_mini = 0
    let translate_mini = 0
    function handleZoom(e) {
        const t = e.transform
        zoom_group.attr("transform", t)
        axis.call(yaxis.scale(e.transform.rescaleY(yscale)))
    }

    const thezoom = zoom().on('zoom', handleZoom)
    plot_outer.call(thezoom)

    return {
        select_window: (stepbegin, stepend, max) => {
            let begin = xscale(stepbegin)
            let size = xscale(stepend) - xscale(stepbegin);
            let scale = plot_width / size
            let translate = -begin
            let yscale =  max_size/max
            scrub_group.attr("transform", `scale(${scale/yscale}, 1) translate(${translate}, 0)`)
            plot_outer.call(thezoom.transform, zoomIdentity.scale(yscale).translate(0, -(plot_height - plot_height/yscale)))
        },
        set_delegate: (delegate) => {
            plot.on('mouseover', function (e, d) { delegate.set_selected(d3.select(this)) } )
            .on('mousedown', function(e, d) { delegate.default_selected = d3.select(this)})
            .on('mouseleave', function (e, d) { delegate.set_selected(delegate.default_selected) } )
        }
    }
}

function ContextViewer(text, data) {
    let current_selected = null

    return {
        default_selected: null,
        set_selected: (d) => {
            if (current_selected !== null) {
                current_selected.attr('stroke', null).attr('stroke-width', null);
            }
            if (d === null) {
                text.text("")
            } else {
                const dd = d.datum()
                if (dd.elem === 'summarized') {
                    text.html(
                        "Small tensors that were not plotted to cutdown on render time.\n" +
                        "Use detail slider to see smaller allocations.")
                } else {
                    text.text(`${dd.elem} ${data.context_for_id(dd.elem)}`)
                }
                d.attr('stroke', 'black').attr('stroke-width', 1).attr('vector-effect', 'non-scaling-stroke')
            }
            current_selected = d
        }
    }
}


function MiniMap(mini_svg, plot, data, left_pad, height=70) {
    let max_at_time = data.max_at_time
    let width = mini_svg.attr('width')
    let plot_width = width - left_pad
    let yscale = scaleLinear().domain([0, data.max_size]).range([height, 0]);
    let minixscale = scaleLinear().domain([0, max_at_time.length]).range([left_pad, width])

    let mini_points = [[max_at_time.length, 0], [0, 0]]

    for (const [i, m] of max_at_time.entries()) {
        let [lastx, lasty] = mini_points[mini_points.length - 1]
        if (m !== lasty) {
            mini_points.push([i, lasty])
            mini_points.push([i, m])
        } else if (i === max_at_time.length - 1) {
            mini_points.push([i, m])
        }
    }


    let points = mini_points.map(([t, o]) => `${minixscale(t)}, ${yscale(o)}`)
    points = points.join(' ')
    mini_svg.append('polygon').attr('points', points).attr('fill', schemeTableau10[0])

    let xscale = scaleLinear().domain([0, max_at_time.length]).range([0, plot_width])


    const brush = brushX()
    brush.extent([[left_pad, 0], [width, height]])
    brush.on('brush', function({selection}) {
        let [begin, end] = selection.map(x => x - left_pad)

        let stepbegin = Math.floor(xscale.invert(begin))
        let stepend = Math.floor(xscale.invert(end))
        let max = 0
        for (let i = stepbegin; i < stepend; i++) {
            max = Math.max(max, max_at_time[i])
        }
        plot.select_window(stepbegin, stepend, max)
    })
    mini_svg.call(brush)
    return {}
}

function Legend(svg, categories) {
    let xstart = width - 100
    let ystart = 30
    plot_svg.append('g').selectAll('rect')
    .data(categories)
    .enter()
    .append('rect')
    .attr('x', (c, i) => xstart)
    .attr('y', (c, i) => ystart + i*15)
    .attr('width', 10)
    .attr('height', 10)
    .attr('fill', (c, i) => schemeTableau10[i % schemeTableau10.length])
    plot_svg.append('g').selectAll('text')
    .data(categories)
    .enter()
    .append('text')
    .attr('x', (c, i) => xstart + 20)
    .attr('y', (c, i) => ystart + i*15 + 8)
    .attr("font-family", "helvetica")
    .attr('font-size', 10)
    .text((c) => c)
    return {}
}


function create(max_entries) {
    let left_pad = 70
    let width = 1024
    let height = 768
    let data = process_alloc_data(max_entries)
    let body = d3.select("body")
    body.selectAll('svg').remove()
    body.selectAll('div').remove()

    if (alloc_data.elements_info.length > max_entries) {
         let d = body.append('div')
         d.append('input')
         .attr("type", "range")
         .attr('min', 0)
         .attr('max', alloc_data.elements_info.length)
         .attr("value", max_entries)
         .on('change', function() {
            create(this.value)
         })
         d.append('label').text('Detail')
    }

    let plot_svg = body.append("svg").attr('width', width).attr('height', height).attr('display', 'block')
    let plot = MemoryPlot(plot_svg, data, left_pad)

    if (alloc_data.categories !== null) {
        Legend(plot_svg.append('g'), alloc_data.categories)
    }

    MiniMap(body.append("svg").attr('width', width).attr('height', 80).attr('display', 'block'), plot, data, left_pad)
    let delegate = ContextViewer(body.append("div").append("pre").text('none'), data)
    plot.set_delegate(delegate)
}

create(15000)

</script>
</body>
</html>
